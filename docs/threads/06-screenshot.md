---
nav: Threads
order: 6
---

# Taking High-Quality Screenshots of Video-Heavy Screens

One of the more interesting challenges in a project I worked on this year was implementing a high-quality screenshot feature. We used [html2canvas](https://www.npmjs.com/package/html2canvas), which—despite its latest release (`v1.4.1`) having been published nearly four years ago—still records close to six million weekly downloads (as of December 18, 2025).

In this project, the application included a screen displaying multiple videos streamed live from different sources. When capturing a screenshot, the client required the resulting image to be extremely sharp, such that text and fine details within each video frame would remain clearly visible even when zoomed in.

Using `html2canvas` with its default configuration introduced two major issues:

1. Video distortion

   Each video frame could appear distorted because we relied on the CSS `object-fit` property to control video layout. This property did not exist when `html2canvas` was originally designed, which means it is not supported out of the box.

2. Insufficient image quality

   The quality of each captured video frame would be equal to—or even worse than—the quality seen during normal viewing. Since the screen contained multiple videos, the available resolution had to be divided across them. For example, with six videos on screen, the effective resolution of each frame in the output image was reduced by at least a factor of six.

We addressed these issues with two key changes:

1. We applied a custom patch to enable `object-fit` support in `html2canvas`.
2. We leveraged the `onClone` callback provided by `html2canvas` to override its default rendering logic. Specifically, we replaced the **canvas** generated by `html2canvas` with frames extracted directly from the original video sources at their native resolution, and then scaled the final composite image up to **4K** quality.

You can see a visual demonstration of this approach in the demo below.

```jsx
import React, { useCallback, useRef, useState, useEffect } from 'react';
import { Button, Flex, InputNumber, Switch, Typography } from 'antd';
import { CameraOutlined } from '@ant-design/icons';
import { screenshotService } from 'ft2025/infrastructure/screenshot';
import { uploadScreenshot } from 'ft2025/app/screenshot';
import { setupApiMocks } from 'ft2025/mocks/api-mocks';
import video4k from '../assets/10s-4k-video.mp4';

const DEFAULT_TARGET_WIDTH = 3840;

export default () => {
  const contentRef = useRef(null);

  const [ready, setReady] = useState(false);
  const [targetWidth, setTargetWidth] = useState(DEFAULT_TARGET_WIDTH);
  const [useClone, setUseClone] = useState(true);

  useEffect(() => {
    let alive = true;
    setupApiMocks().then(() => alive && setReady(true));
    return () => {
      alive = false;
    };
  }, []);

  const takeScreenshot = useCallback(async () => {
    if (!contentRef.current || !ready) {
      console.warn("It's not ready to take the screenshot");
      return;
    }

    const canvas = await screenshotService.captureScreenshot(
      contentRef.current,
      {
        targetWidth,
        useClone,
      },
    );

    const blob = await screenshotService.convertToBlob(canvas);

    await uploadScreenshot({ image: blob });
  }, [ready, targetWidth, useClone]);

  return (
    <Flex vertical gap="middle" align="center">
      <Button
        type="primary"
        icon={<CameraOutlined />}
        onClick={() => takeScreenshot()}
      >
        {'Take a screenshot'}
      </Button>
      <Flex gap="small" align="center" wrap="wrap">
        <Flex gap="small" align="center">
          <Typography.Text>Target width</Typography.Text>
          <InputNumber
            min={640}
            max={7680}
            step={160}
            value={targetWidth}
            onChange={(value) => setTargetWidth(value ?? DEFAULT_TARGET_WIDTH)}
          />
        </Flex>
        <Flex gap="small" align="center">
          <Typography.Text>Use real video frames</Typography.Text>
          <Switch checked={useClone} onChange={setUseClone} />
        </Flex>
      </Flex>
      <div ref={contentRef}>
        <video
          src={video4k}
          autoPlay
          muted
          controls={false}
          playsInline
          disablePictureInPicture
          onContextMenu={(e) => e.preventDefault()}
          style={{
            pointerEvents: 'none',
            width: 500,
            height: 'auto',
            objectFit: 'contain',
          }}
        />
      </div>
    </Flex>
  );
};
```
